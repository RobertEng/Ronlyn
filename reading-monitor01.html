<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width">
<link rel="manifest" href="manifest.webapp">
    <title>Speech Recognition tester</title>

<style>
    body, html {
      margin: 10;
    }

    html {
      height: 100%;
    }

    body {
      height: inherit;
      overflow: hidden;
    }

    h1 {
      font-family: sans-serif;
      text-align: center;
      padding: 20px;
    }
    p {
      font-family: sans-serif;
      font-size: 80%;
      text-align: left;
    }

    div {
      overflow: auto;
      position: relative;
    }

    ul {
      margin: 0;
    }

    .hints span {
      text-shadow: 0px 0px 6px rgba(255,255,255,0.7);
    }
</style>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
</head>

<body>
  <h1>Speech recognition tester</h1>
  <input type="button" id="listenBtn" value="listen to me read">
  <br>
<div class="sentence" id=0>
  <span class="word" id=0>The</span>
  <span class="word" id=1>quick</span>
  <span class="word" id=2>The</span>
  <span class="word" id=3>quick</span>
</div>
<div class="sentence" id=1>
  <span class="word" id=0>The</span>
  <span class="word" id=1>quick</span>
  <span class="word" id=2>brown</span>
  <span class="word" id=3>fox</span>
  <span class="word" id=4>jumped</span>
  <span class="word" id=5>over</span>
  <span class="word" id=6>the</span>
  <span class="word" id=7>lazy</span>
  <span class="word" id=8>dog</span><span class="word" id=9>.</span>
</div>
<br>
<div class="sentence" id=2>
  <span class="word" id=0>Now</span>
  <span class="word" id=1>is</span>
  <span class="word" id=2>the</span>
  <span class="word" id=3>time</span>
  <span class="word" id=4>for</span>
  <span class="word" id=5>all</span>
  <span class="word" id=6>good</span>
  <span class="word" id=7>men</span>
  <span class="word" id=8>to</span>
  <span class="word" id=9>come</span>
  <span class="word" id=10>to</span>
  <span class="word" id=11>the</span>
  <span class="word" id=12>aid</span>
  <span class="word" id=13>of</span>
  <span class="word" id=14>the</span>
  <span class="word" id=15>party</span>
  <span class="word" id=16>.</span>
</div>
<br>
<div class="sentence" id=3>
  <span class="word" id=0>Is</span>
  <span class="word" id=1>Ronlyn</span>
  <span class="word" id=2>a</span>
  <span class="word" id=3>pumpkin</span>
  <span class="word" id=4>.</span>
</div>
<br>
<p><span>sentence idx:</span><span id="sentenceIdx">0</span></p>
<p><span>word idx:</span><span id="wordIdx">0</span></p>
<p><span>last spoken word:</span><span id="lastSpokenWord">0</span></p>
<p id="confidence">no error</p>
<p id="diagnostic">no error</p>

<script>
'use strict';
// ECMASCript6 class syntax only

// types of tokens
const  TOKEN_WORD = 0;
const  TOKEN_TERMINALPUNCTUATION = 1;
const  TOKEN_INTERIMPUNCTUATION = 2;
const  TOKEN_PROPERNOUN = 3;

class ReadingMonitor {
    // class variables
    constructor(name) {
      this._name = name;
    }
    get name() {
        return this._name;
    }
    set name(newName) {
        this._name = newName;
    }
    set timeout(msecs) {
      // period of time from start() to onspeechend
      this._timeout = msecs;
    }
    setTimerStart() {
      this._startTime = new Date();
      this.diagnosticMsg = "timerStartTime: started at " + this._startTime;
    }
    timerIsActive() {
      var current  = new Date();
      // period of time of silences
      this.diagnosticMsg = "timerIsActive(): " + this.timerElapsedTime < this._timeout;
      return (this.timerElapsedTime < this._timeout);
    }
    get timerElapsedTime() {
      var current  = new Date();
      return current - this._startTime;
    }
    set retries(retries) {
      // how many (re)tries before hint
      this._retries = retries;
    }
    set sentenceIdxElementId(id) {
      try {
        this._sentenceIdxElement  = document.getElementById(id);
        this._sentenceIdxElement.innerText = "0"; // touch test
      }
      catch(e) {
        this.diagnosticMsg = "sentenceIdxElementId setter: invalid Element id "+id;
      };
    }
    set wordIdxElementId(id) {
        //check typeof parameter
        try {
          this._wordIdxElement  = document.getElementById(id);
          this._wordIdxElement.innerText = "0"; // touch test
        }
        catch(e) {
          this.diagnosticMsg = "wordIdxElementId setter: invalid Element id "+id;
        };
      }
    set diagnosticElementId(id) {
        this._diagnosticElement = document.getElementById(id);
    }
    set diagnosticMsg(msg) {
        //check typeof parameter
        try {
          var time = new Date();
          var timestamp = time.toLocaleTimeString();
//          header = time.getHours()+":"+time.getMinutes()+":"+time.getSeconds()+"."+time.getMilliseconds();
          this._diagnosticElement.textContent = timestamp + ":" + msg;
        }
        catch(e) {
          console.log("diagnosticMsg: cannot access diagnostic field");
        }
        finally {
          console.log("RMdiag-"+timestamp + ": " + msg);
        };

      }
    set listenButtonElementId(buttonId) {
      try {
        this._listenButtonElement = document.getElementById(buttonId);
      }
      catch(e) {
        this.diagnosticMsg = "listenButtonElementId setter: Invalid element id "+buttonId;
      }
    }
    set listenButtonLabel(label) {
      try {
        this._listenButtonElement.defaultValue = label;
      }
      catch(e) {
        this.diagnosticMsg = "listenButtonLabel setter: Error setting listentButtonLabel with"+label;
      }
    }
    get currentSentenceIdx() {
        return this._sentenceIdx;
    }
    set currentSentenceIdx(sentenceIdx) {
        // check if Idx is valid based on DOM
        this._sentenceIdx = sentenceIdx;
        if (typeof this._sentenceIdxElement != 'undefined' && this._sentenceIdxElement != null)
          this._sentenceIdxElement.innerText = sentenceIdx.toString();
        this._lastWordIdx = document.getElementsByClassName("sentence")[this._sentenceIdx].childElementCount - 1;
    }
    get currentWordIdx() {
        return this._wordIdx;
    }
    set currentWordIdx(wordIdx) {
      // check if Idx is valid based on DOM
        this._wordIdx = wordIdx;
        if (typeof this._wordIdxElement != 'undefined' & this._wordIdxElement != null)
          this._wordIdxElement.innerText = wordIdx.toString();
    }
    get currentWord() { // should be assigned only when sentence or word idx changed is set or changed
      return document.getElementsByClassName("sentence")[this._sentenceIdx].getElementsByClassName("word")[this._wordIdx].innerHTML;
      // converts source html sentence <div>s into sentence containers <div>s/word <span>s
    }
    get lastWordIdx() {
      return this._lastWordIdx;
    }
    isLastWord() {
      return this._wordIdx >= this._lastWordIdx;
    }
    endOfSentence() {
      return this._wordIdx >= this._lastWordIdx;
    }
    isLastSentence() {
      return this._sentenceIdx >= this._lastSentenceIdx;
    }
    parseSentences() {
          // can the existing html support parsing into the prescribed format?
          this._lastSentenceIdx = 999;
    }
    thisSentence() {
      this._lastWordIdx = document.getElementsByClassName("sentence")[this._sentenceIdx].childElementCount - 1;
      this.currentWordIndicator("underline");
//      document.getElementsByClassName("sentence")[this._sentenceIdx].getElementsByClassName("word")[this._wordIdx].style.textDecoration = "underline";
    }
    firstSentence() {
      // check for last sentence
      this.currentSentenceIdx = 0;
      this.currentWordIdx = 0;
      this.thisSentence();
    }
    nextSentence() {
      // check for last sentence
      if (this.isLastSentence()) {
        console.log("no more sentences")
      }
      else {
        this.currentSentenceIdx += 1;
        this.currentWordIdx = 0;
        this.thisSentence();
      }
    }
    currentWordIndicator(state) {
      document.getElementsByClassName("sentence")[this._sentenceIdx].getElementsByClassName("word")[this._wordIdx].style.textDecoration = state;
    }
    nextToken() {
      // consider this a lexical analyzer
      // positions to the next valid word. Because the speech recognitionengine does not recognize punctuations
      // this method skips punctuations marks and also positions to the first word of a new sentence when
      // terminal punctation is encountered. The method will return the type of token it encountered though.
      var interimPunctuationPattern = new RegExp(/[,\/#$%\^&\*;:{}=\-_`~()]\"/);
      var terminalPunctuationPattern = new RegExp(/.!?/);
      var returnVal = TOKEN_WORD; // assume the token is a word
      //      var properNamePattern = new RegExp(/^[A-Z]/); first letter uppercase... less conficent if at beginning of sentence
      //      var possessivePattern = new RegExp(/^[A-Z]/); first letter uppercase... less conficent if at beginning of sentence
      this.currentWordIndicator("none");
//      document.getElementsByClassName("sentence")[this._sentenceIdx].getElementsByClassName("word")[this._wordIdx].style.textDecoration = "none";
      this.currentWordIdx += 1; // lookahead to the next token to be read
      if (this.isLastWord()) { // last word in sentence encountered
//        if (terminalPunctuationPattern.test(this._wordIdx)) {
      if (terminalPunctuationPattern.test(this.currentWord)) {
          this.nextSentence();
          returnVal = TOKEN_TERMINALPUNCTUATION;
        }
        else {
          // corner case where last word/token is not a terminal punctuation and must be a word
          this.diagnosticMsg = "warning: last token in sentence is not a terminal punctuation"
        }
        // else if proper noun
        // else if possessive noun
      }
      else {  // not last word in sentence
        if (interimPunctuationPattern.test(this._wordIdx)) {
          this.nextToken(); // skip recursively
          returnVal = TOKEN_INTERIMPUNCTUATION;

        }
        else {
          this.currentWordIndicator("underline");
        }
      }
      return returnVal;
    }
    matchWord(spokenWord) {
      // need code to manage special cases: proper noun not already recognized
      var properNamePattern = new RegExp(/^[A-Z]/); //first letter uppercase... less conficent if at beginning of sentence
      if (spokenWord.toLowerCase() == this.currentWord.toLowerCase()) {
        return true;
      }
      else if (properNamePattern.test(this.currentWord)) {
        this.diagnosticMsg = "possible proper noun encountered "+this.currentWord;
      }
    }
    initialize() {
      var SpeechRecognition = SpeechRecognition || webkitSpeechRecognition

      // can the existing html support the prescribed format?


//      document.getElementsByClassName("sentence")[this._sentenceIdx].getElementsByClassName("word")[this._wordIdx].style.textDecoration = "underline";
      this._recognition = new SpeechRecognition();
      this._recognition.lang = 'en-US';
      this._recognition.interimResults = true;
      this._recognition.continuous = true;
      this._recognition.maxAlternatives = 1;
      var recognition = this._recognition;
      var thisMonitor = this; // listener context will reference MyReadingMonitor as self
      //
      // Define event handling
      //
      this._listenButtonElement.onclick = function(event) {
        myReadingMonitor.setTimerStart();
        myReadingMonitor.diagnosticMsg = 'listenBtn::onclick()';
        myReadingMonitor.listenButtonLabel = "stop listening";
        recognition.start();
      }

      recognition.onresult = function(event) {
//      ////////////
//      implement these interfaces someday when the following references are available. Until then, just split the transcript
//        var spokenEvent = SpeechRecognitionEvent || webkitSpeechRecognitionEvent
//        var SpeechRecognition = SpeechRecognitionAlternative || webkitSpeechRecognitionAlternative
//      Perhaps the grammar object will be available by then too.
//      ////////////
        thisMonitor.diagnosticMsg = "recognition.onresult: triggered";
        var spokenResults = event.results[0].isFinal;
        var spokenWords = event.results[event.results.length - 1][0].transcript.split(" ");
        var isFinalResult = event.results[0].isFinal;
         thisMonitor.diagnosticMsg = "recognition.onresult: is Final?: "+event.results[0].isFinal;
         var w;
         var nextTokenType;
         for (w = 0; w < spokenWords.length; w++) {
           thisMonitor.diagnosticMsg = "recognition.onresult: written word: "+thisMonitor.currentWord;
           thisMonitor.diagnosticMsg = "recognition.onresult: spoken word["+ w.toString()+"]:"+spokenWords[w];
           if (thisMonitor.matchWord(spokenWords[w])) { //should strip blanks too
              nextTokenType = thisMonitor.nextToken();
              if (nextTokenType == TOKEN_TERMINALPUNCTUATION) {
                  thisMonitor.diagnosticMsg = "recognition.onresult: end of sentence";
                  recognition.abort();
                  thisMonitor.diagnosticMsg = "recognition.onresult: aborted";
                  thisMonitor.listenButtonLabel = "listen to me read";
              }
           }
         }

//         thisMonitor.listenButtonLabel = "listen to me read";
         thisMonitor.diagnosticMsg = 'Result received: ' + spokenWords;
//         console.log('confidence: ' + event.results[0][0].confidence);
//         console.log("result[last]:"+spokenWords);
//         if ((event.results.length - 1) >= 1)
//         console.log('result[0]: ' + event.results[0][0].transcript);
      } // onresult

      recognition.onspeechend = function() {
         thisMonitor.diagnosticMsg = "recognition.onspeechend";

         if (thisMonitor.timerIsActive()) {
//           listenBtn.defaultValue = "stop listening";
           thisMonitor.diagnosticMsg = "recognition.onspeechend: keep listening";
//           recognition.start();
         }
         else {
//            listenBtn.defaultValue = "listen to me read";
            thisMonitor.diagnosticMsg = "recognition.onspeechend: timer expired";
          }
       }

       recognition.onend = function() {
          thisMonitor.diagnosticMsg = "recognition.onend";
          thisMonitor.diagnosticMsg = "timer ElapsedTime: "+ thisMonitor.timerElapsedTime;
          if (thisMonitor.timerIsActive()) {
            listenBtn.defaultValue = "stop listening";
            thisMonitor.diagnosticMsg = "recognition.onspeechend: keep listening";
            recognition.start();
          }
          else {
             listenBtn.defaultValue = "listen to me read";
             thisMonitor.diagnosticMsg = "recognition.onspeechend: timer expired";
           }
        }

       recognition.onsoundend = function() {
         // event fires immediately after onspeechend
         thisMonitor.diagnosticMsg = "recognition.onsoundend";
         recognition.stop();
         listenBtn.defaultValue = "listen to me read";
       }

       recognition.onnomatch = function(event) {
         thisMonitor.diagnosticMsg = "recognition.onnomatch:";
       }

       recognition.onerror = function(event) {
         thisMonitor.diagnosticMsg = 'recognition.onerror: ' + event.error;
         // timeout with no sound triggers this event
       }

             // insert code to change current word and sentence
    } // initialize()
} // MyReadingMonitor

  var myReadingMonitor = new ReadingMonitor("Speech recognition tester");

  // register html field names
  myReadingMonitor.diagnosticElementId ="diagnostic";
  myReadingMonitor.sentenceIdxElementId = "sentenceIdx";
  myReadingMonitor.wordIdxElementId = "wordIdx";
  myReadingMonitor.listenButtonElementId = "listenBtn";
  myReadingMonitor.timeout = 10000;

  myReadingMonitor.parseSentences();
  myReadingMonitor.firstSentence();
  myReadingMonitor.initialize();

</script>
  </body>
</html>
